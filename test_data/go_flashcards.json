[
  {
    "deck_name": "Go语言基础",
    "cards": [
      {
        "question": "Go语言的垃圾回收机制是如何工作的？",
        "answer": "Go语言使用三色标记清除算法进行垃圾回收。主要步骤包括：1) 标记阶段：从根对象开始，将可达对象标记为灰色；2) 扫描阶段：将灰色对象引用的对象标记为灰色，并将原灰色对象标记为黑色；3) 清除阶段：回收所有白色（未标记）对象。Go的GC是并发执行的，可以与用户程序同时运行，减少了STW(Stop-The-World)时间。",
        "tag_name": "内存管理"
      },
      {
        "question": "Go语言的goroutine和线程有什么区别？",
        "answer": "1) 创建成本：goroutine创建成本低，初始栈大小仅2KB，可动态增长；线程创建成本高，通常需要1MB以上栈空间。2) 调度方式：goroutine由Go运行时调度器在用户态调度，采用M:N模型；线程由操作系统内核调度。3) 切换成本：goroutine切换成本低，仅需保存少量寄存器；线程切换需要保存完整上下文，成本高。4) 数量限制：goroutine可轻松创建数十万个；线程数量受系统限制。",
        "tag_name": "并发"
      },
      {
        "question": "Go语言的channel有什么作用？",
        "answer": "channel是Go语言中用于goroutine之间通信的管道，实现了CSP(Communicating Sequential Processes)并发模型。主要作用：1) 实现goroutine间的同步和数据传递；2) 提供类型安全的通信机制；3) 支持带缓冲和不带缓冲两种模式；4) 可用于控制并发数量；5) 实现生产者-消费者模式。channel是Go语言并发编程的核心组件，遵循'不要通过共享内存来通信，而要通过通信来共享内存'的设计理念。",
        "tag_name": "并发"
      },
      {
        "question": "Go语言的接口是如何实现的？",
        "answer": "Go语言采用隐式接口实现机制，任何类型只要实现了接口中定义的所有方法，就被认为实现了该接口，无需显式声明。接口值由两部分组成：类型和值。空接口interface{}可表示任何类型。接口的主要特点：1) 鸭子类型：如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子；2) 组合优于继承；3) 接口解耦；4) 支持多态。这种设计使得Go的接口非常灵活和轻量。",
        "tag_name": "接口"
      },
      {
        "question": "Go语言的defer语句有什么特点和用途？",
        "answer": "defer语句用于延迟函数的执行，直到包含它的函数返回时才执行。特点：1) 执行顺序：多个defer按LIFO(后进先出)顺序执行；2) 参数求值：defer函数的参数在defer语句执行时求值；3) 可修改命名返回值。主要用途：1) 资源释放：关闭文件、解锁互斥锁等；2) 异常处理：配合recover捕获panic；3) 代码清理：确保某些操作在函数退出前执行。defer是Go语言处理资源管理和错误清理的重要机制。",
        "tag_name": "基础语法"
      }
    ]
  },
  {
    "deck_name": "Go语言面试题",
    "cards": [
      {
        "question": "如何实现一个线程安全的Go单例模式？",
        "answer": "Go中实现线程安全的单例模式有几种方法：1) sync.Once：最推荐的方式，使用sync.Once确保初始化函数只执行一次。示例：\nvar instance *Singleton\nvar once sync.Once\n\nfunc GetInstance() *Singleton {\n    once.Do(func() {\n        instance = &Singleton{}\n    })\n    return instance\n}\n2) 双重检查锁：使用sync.Mutex实现，但代码较复杂。3) init函数：在包初始化时创建单例，但不够灵活。sync.Once是最简洁高效的解决方案。",
        "tag_name": "设计模式"
      },
      {
        "question": "Go语言的select语句有什么作用？",
        "answer": "select语句是Go语言中用于处理多个channel操作的控制结构。特点：1) 随机选择：当多个case同时就绪时，随机选择一个执行；2) 阻塞等待：如果没有case就绪，select会阻塞；3) 超时处理：配合time.After实现超时控制；4) 非阻塞操作：使用default子句实现非阻塞操作。主要用途：1) 多路复用：同时监控多个channel；2) 超时控制：防止永久阻塞；3) 实现超时和取消机制；4) 处理多个数据源。select是Go并发编程的重要工具。",
        "tag_name": "并发"
      },
      {
        "question": "Go语言的context包有什么作用？",
        "answer": "context包用于在API和进程间传递截止时间、取消信号和其他请求范围的值。主要功能：1) 取消控制：通过WithCancel创建可取消的context，用于取消长时间运行的操作；2) 超时控制：WithTimeout和WithDeadline设置超时时间；3) 传递值：WithValue在context中传递请求范围的值。使用场景：1) HTTP请求处理；2) 数据库查询；3) RPC调用；4) 任何需要取消或超时的操作。context是Go服务端编程的标准模式，确保资源正确释放和避免泄漏。",
        "tag_name": "标准库"
      },
      {
        "question": "Go语言的reflect包有什么作用和限制？",
        "answer": "reflect包提供了运行时反射能力，允许程序在运行时检查类型信息并操作对象。主要功能：1) 类型检查：TypeOf获取类型信息；2) 值操作：ValueOf获取和修改值；3) 结构体操作：获取字段、方法等信息；4) 函数调用：动态调用方法。限制：1) 性能开销：反射比直接调用慢；2) 类型安全：编译时无法检查类型错误；3) 代码可读性：反射代码难以理解和维护；4) 不支持所有类型：如非导出字段。使用原则：仅在必要时使用，优先考虑静态类型解决方案。",
        "tag_name": "反射"
      },
      {
        "question": "Go语言的pprof工具有什么作用？",
        "answer": "pprof是Go的性能分析工具，用于可视化和分析性能数据。主要功能：1) CPU分析：识别CPU热点；2) 内存分析：检测内存泄漏和分配模式；3) 阻塞分析：发现goroutine阻塞原因；4) 互斥锁分析：检测锁竞争。使用方式：1) 导入_ 'net/http/pprof'包；2) 访问/debug/pprof/端点获取数据；3) 使用go tool pprof分析数据。pprof是Go性能优化的关键工具，帮助开发者定位性能瓶颈，优化代码效率。",
        "tag_name": "性能优化"
      }
    ]
  },
  {
    "deck_name": "Go语言高级特性",
    "cards": [
      {
        "question": "Go语言的内存模型是什么？",
        "answer": "Go内存模型定义了goroutine之间如何通过内存交互保证正确性。核心原则：1) Happens-Before关系：定义了内存操作的偏序关系；2) 同步原语：channel、sync包、atomic包提供同步保证；3) 可见性：一个goroutine的写操作对其他goroutine可见需要同步。关键点：1) channel发送happens-before对应接收；2) mutex解锁happens-before再次锁定；3) Once.Do(f)happens-before f返回；4) 原子操作提供顺序一致性。理解内存模型对编写正确的并发程序至关重要。",
        "tag_name": "并发"
      },
      {
        "question": "Go语言的cgo有什么作用和注意事项？",
        "answer": "cgo允许Go程序调用C代码，实现与C库的互操作。作用：1) 复用现有C库；2) 访问系统底层功能；3) 性能关键部分优化。注意事项：1) 性能开销：Go和C之间的调用有开销；2) 内存管理：需要手动管理C侧内存；3) 线程安全：C代码可能不是线程安全的；4) 跨平台：不同平台可能有差异；5) 调试困难：混合语言调试复杂。使用原则：尽量减少cgo使用，优先考虑纯Go解决方案，必要时使用但注意边界处理。",
        "tag_name": "互操作"
      },
      {
        "question": "Go语言的testing包有哪些高级特性？",
        "answer": "Go的testing包提供了丰富的测试功能：1) 子测试：使用t.Run()创建嵌套测试；2) 表格测试：使用循环和子测试实现数据驱动测试；3) 基准测试：使用testing.B进行性能测试；4) 示例测试：Example函数生成文档和验证；5) 模糊测试：testing.F进行模糊测试；6) 并行测试：t.Parallel()并行执行测试；7) 覆盖率：-cover参数生成覆盖率报告；8) Mock和Stub：使用接口和依赖注入实现。这些特性使Go的测试系统非常强大和灵活。",
        "tag_name": "测试"
      },
      {
        "question": "Go语言的错误处理最佳实践是什么？",
        "answer": "Go错误处理最佳实践：1) 显式错误检查：总是检查错误，不要忽略；2) 错误包装：使用fmt.Errorf或errors.Wrap添加上下文；3) 错误类型：自定义错误类型提供更多信息；4) 错误处理策略：根据错误类型采取不同处理；5) 错误日志：记录足够信息但不暴露敏感数据；6) 错误传播：向上层传递错误时保持原始信息；7) 错误恢复：仅在适当位置使用recover；8) 错误文档：清晰说明函数可能返回的错误。良好的错误处理是Go程序健壮性的关键。",
        "tag_name": "错误处理"
      },
      {
        "question": "Go语言的runtime包有哪些重要功能？",
        "answer": "runtime包提供了与Go运行时系统交互的功能：1) 调度控制：GOMAXPROCS设置最大处理器数；2) 垃圾回收：GC、ReadMemStats控制GC行为；3) 内存统计：MemStats获取内存使用情况；4) Goroutine控制：Goexit、Gosched控制goroutine执行；5) 环境信息：GOOS、GOARCH获取平台信息；6) 性能分析：SetCPUProfileRate等分析工具；7) 调试支持：Caller、FuncForPC等调试函数。runtime包是理解Go运行时行为和进行性能优化的重要工具。",
        "tag_name": "运行时"
      }
    ]
  }
]