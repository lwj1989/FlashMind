# FlashMind 使用手册

## 目录

1. [项目概述](#项目概述)
2. [系统要求](#系统要求)
3. [安装指南](#安装指南)
   - [后端安装](#后端安装)
   - [前端安装](#前端安装)
   - [数据库初始化](#数据库初始化)
4. [快速开始](#快速开始)
   - [启动服务](#启动服务)
   - [导入测试数据](#导入测试数据)
5. [功能介绍](#功能介绍)
   - [卡包管理](#卡包管理)
   - [标签管理](#标签管理)
   - [卡片管理](#卡片管理)
   - [学习功能](#学习功能)
   - [导入导出](#导入导出)
   - [统计报告](#统计报告)
6. [使用指南](#使用指南)
   - [创建卡包](#创建卡包)
   - [添加标签](#添加标签)
   - [创建卡片](#创建卡片)
   - [学习卡片](#学习卡片)
   - [导入数据](#导入数据)
   - [导出数据](#导出数据)
7. [API文档](#api文档)
   - [卡包API](#卡包api)
   - [标签API](#标签api)
   - [卡片API](#卡片api)
   - [导入导出API](#导入导出api)
8. [TXT格式说明](#txt格式说明)
   - [基本语法](#基本语法)
   - [标签使用](#标签使用)
   - [示例文件](#示例文件)
9. [常见问题解答](#常见问题解答)
10. [开发指南](#开发指南)
    - [项目结构](#项目结构)
    - [运行测试](#运行测试)
    - [贡献指南](#贡献指南)

---

## 项目概述

FlashMind 是一个基于间隔重复记忆算法的智能学习系统，采用 Go 语言作为后端，Vue 3 作为前端，SQLite 作为数据库。该系统帮助用户高效地学习和记忆各种知识点，特别适合语言学习、技术知识积累、考试准备等场景。

### 核心特性

- **智能记忆算法**：基于 SM-2 算法的间隔重复系统，根据用户掌握程度自动调整复习间隔
- **多格式支持**：支持 JSON、CSV 和 TXT 格式的数据导入导出
- **标签系统**：灵活的标签管理，支持按标签分类学习和统计
- **Markdown 支持**：问题和答案支持 Markdown 格式，支持代码高亮
- **响应式设计**：适配桌面和移动设备，支持深色模式
- **本地优先**：数据存储在本地，保护隐私，无需网络连接

### 技术栈

- **后端**：Go + Gin + GORM + SQLite
- **前端**：Vue 3 + Vite + TailwindCSS
- **测试**：Go 内置测试框架 + Vitest
- **记忆算法**：SM-2 间隔重复算法

---

## 系统要求

### 硬件要求

- CPU：1GHz 或更快
- 内存：2GB RAM 或更多
- 硬盘：100MB 可用空间

### 软件要求

- **操作系统**：Windows 10/11，macOS 10.14+，Linux
- **Go 环境**：Go 1.21 或更高版本
- **Node.js 环境**：Node.js 16 或更高版本
- **浏览器**：Chrome 90+，Firefox 88+，Safari 14+，Edge 90+

---

## 安装指南

### 后端安装

1. **克隆项目**
   ```bash
   git clone <项目地址>
   cd FlashMind
   ```

2. **进入后端目录**
   ```bash
   cd backend
   ```

3. **安装依赖**
   ```bash
   go mod tidy
   ```

4. **配置环境变量**
   ```bash
   cp .env.example .env
   ```
   编辑 `.env` 文件，根据需要修改配置：
   ```
   PORT=8080
   GIN_MODE=debug
   DB_PATH=./flashcard.db
   ```

### 前端安装

1. **进入前端目录**
   ```bash
   cd frontend
   ```

2. **安装依赖**
   ```bash
   npm install
   ```

3. **配置环境变量**
   创建 `.env` 文件：
   ```
   VITE_API_BASE_URL=http://localhost:8080/api/v1
   ```

### 数据库初始化

1. **启动后端服务**
   ```bash
   cd backend
   go run cmd/server/main.go
   ```

2. **数据库将自动初始化**
   - 系统会自动创建 `flashcard.db` 文件
   - 自动创建所需的表结构：`decks`、`tags`、`cards`、`reviews`

---

## 快速开始

### 一键启动（推荐）

项目提供了一键启动脚本，可以自动处理所有依赖安装和服务启动：

1. **启动所有服务**
   ```bash
   ./start.sh
   ```
   
   该脚本会自动：
   - 安装Go和Node.js依赖
   - 编译后端服务
   - 启动前后端服务
   - 如果服务已运行，会先停止再启动（重启功能）

2. **访问应用**
   - 前端界面: http://localhost:5173
   - 后端API: http://localhost:8080

### 管理服务

```bash
# 停止所有服务
./stop.sh

# 停止服务并清理日志文件
./stop.sh --clean-logs

# 检查服务运行状态
./status.sh

# 重启服务（等同于执行 start.sh）
./start.sh
```

### 手动启动（开发模式）

如果需要单独启动服务进行开发：

1. **启动后端服务**
   ```bash
   cd backend
   go run cmd/server/main.go
   ```
   服务将在 `http://localhost:8080` 启动

2. **启动前端服务**
   在新的终端窗口中：
   ```bash
   cd frontend
   npm run dev
   ```
   前端将在 `http://localhost:5173` 启动

3. **访问应用**
   打开浏览器，访问 `http://localhost:5173`

### 导入测试数据

1. **访问导入导出页面**
   - 在应用中点击 "导入导出" 菜单项

2. **选择测试数据文件**
   - 使用项目提供的 `test_data/go_flashcards.json` 文件
   - 点击 "选择文件" 按钮，选择该文件

3. **执行导入**
   - 点击 "导入" 按钮
   - 等待导入完成，查看导入报告

4. **查看导入结果**
   - 导入成功后，可以在首页看到三个卡包：
     - Go语言基础
     - Go语言面试题
     - Go语言高级特性
   - 每个卡包包含多个卡片和标签

---

## 功能介绍

### 卡包管理

卡包是 FlashMind 中的顶层组织单位，用于分类管理相关的学习卡片。

- **创建卡包**：为不同主题或科目创建独立的卡包
- **查看卡包**：浏览所有卡包，查看每个卡包的统计信息
- **编辑卡包**：修改卡包名称，归档或删除卡包
- **卡包统计**：查看卡包中的卡片总数、待复习卡片数、标签数等

### 标签管理

标签用于对卡片进行分类，支持跨卡包的标签管理。

- **创建标签**：在卡包下创建标签，用于分类卡片
- **查看标签**：浏览卡包下的所有标签，查看标签统计
- **编辑标签**：修改标签名称，删除标签
- **标签统计**：查看标签下的卡片数、待复习卡片数等

### 卡片管理

卡片是 FlashMind 的核心单元，包含问题和答案。

- **创建卡片**：创建新的学习卡片，支持 Markdown 格式
- **编辑卡片**：修改卡片的问题和答案
- **删除卡片**：删除不需要的卡片
- **搜索卡片**：按关键词搜索卡片
- **批量操作**：支持批量选择和操作卡片

### 学习功能

基于 SM-2 算法的智能学习系统，根据用户掌握程度自动调整复习间隔。

- **学习队列**：系统自动生成今日待复习的卡片队列
- **学习模式**：显示问题，用户思考后翻转查看答案
- **反馈机制**：提供三档反馈选项：
  - **Again**：不熟悉，下次尽快复习
  - **Hard**：有点熟悉，下次适当延长复习间隔
  - **Good**：很熟悉，大幅延长复习间隔
- **进度跟踪**：显示学习进度，今日完成情况等

### 导入导出

支持多种格式的数据导入导出，方便数据迁移和备份。

- **格式支持**：
  - JSON：结构化数据格式，适合程序处理
  - CSV：表格数据格式，适合 Excel 等工具编辑
  - TXT：纯文本格式，易于手动编辑和阅读
- **导入功能**：
  - 支持批量导入卡片
  - 自动创建卡包和标签
  - 重复检测和报告
  - 导入失败时自动回滚
- **导出功能**：
  - 按卡包导出
  - 按标签分组
  - 包含导出报告

### 统计报告

提供多维度的学习数据统计，帮助用户了解学习进度和效果。

- **主页统计**：每个卡包的总卡片数、待复习卡片数、标签数
- **详情页统计**：按标签/今日/本周完成数、学习时长
- **导入导出报告**：成功/跳过/失败条目统计

---

## 使用指南

### 创建卡包

1. **访问卡包管理页面**
   - 点击侧边栏的 "卡包" 菜单项

2. **创建新卡包**
   - 点击 "新建卡包" 按钮
   - 输入卡包名称
   - 点击 "保存" 按钮

3. **查看卡包**
   - 创建成功后，卡包将显示在卡包列表中
   - 点击卡包名称可以查看卡包详情

### 添加标签

1. **访问卡包详情页面**
   - 在卡包列表中点击要添加标签的卡包

2. **创建标签**
   - 在卡包详情页面，点击 "新建标签" 按钮
   - 输入标签名称
   - 点击 "保存" 按钮

3. **管理标签**
   - 标签创建后，会显示在标签列表中
   - 可以编辑标签名称或删除标签

### 创建卡片

1. **访问卡片管理页面**
   - 点击侧边栏的 "卡片" 菜单项

2. **创建新卡片**
   - 点击 "新建卡片" 按钮
   - 选择卡包和标签
   - 输入问题和答案（支持 Markdown 格式）
   - 点击 "保存" 按钮

3. **编辑卡片**
   - 在卡片列表中点击要编辑的卡片
   - 修改卡片内容
   - 点击 "保存" 按钮

### 学习卡片

1. **访问学习页面**
   - 在首页或卡包详情页面，点击 "开始学习" 按钮

2. **学习卡片**
   - 系统会显示卡片的问题
   - 思考答案后，点击 "显示答案" 按钮
   - 查看答案后，选择掌握程度：
     - **Again**：不熟悉，下次尽快复习
     - **Hard**：有点熟悉，下次适当延长复习间隔
     - **Good**：很熟悉，大幅延长复习间隔

3. **查看进度**
   - 学习过程中可以查看当前进度
   - 完成学习后，可以查看今日学习统计

### 导入数据

1. **访问导入导出页面**
   - 点击侧边栏的 "导入导出" 菜单项

2. **选择导入格式**
   - 选择要导入的文件格式（JSON、CSV 或 TXT）
   - 点击 "选择文件" 按钮，选择要导入的文件

3. **预览和导入**
   - 系统会解析文件并显示预览信息
   - 确认无误后，点击 "导入" 按钮
   - 等待导入完成，查看导入报告

### 导出数据

1. **访问导入导出页面**
   - 点击侧边栏的 "导入导出" 菜单项

2. **选择导出选项**
   - 选择要导出的卡包
   - 选择导出格式（JSON、CSV 或 TXT）
   - 选择是否按标签分组

3. **执行导出**
   - 点击 "导出" 按钮
   - 系统会生成导出文件并自动下载

---

## API文档

### 卡包API

#### 获取所有卡包
```
GET /api/v1/decks
```

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "获取卡包列表成功",
  "data": [
    {
      "id": 1,
      "name": "Go语言基础",
      "archived": false,
      "created_at": "2023-11-01T10:00:00Z",
      "stats": {
        "total_cards": 5,
        "due_cards": 2,
        "total_tags": 3
      }
    }
  ]
}
```

#### 创建卡包
```
POST /api/v1/decks
```

**请求体**：
```json
{
  "name": "新卡包"
}
```

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "卡包创建成功",
  "data": {
    "id": 2,
    "name": "新卡包",
    "archived": false,
    "created_at": "2023-11-01T10:00:00Z"
  }
}
```

#### 获取单个卡包
```
GET /api/v1/decks/{id}
```

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "获取卡包成功",
  "data": {
    "id": 1,
    "name": "Go语言基础",
    "archived": false,
    "created_at": "2023-11-01T10:00:00Z"
  }
}
```

#### 更新卡包
```
PATCH /api/v1/decks/{id}
```

**请求体**：
```json
{
  "name": "更新的卡包名称",
  "archived": true
}
```

#### 删除卡包
```
DELETE /api/v1/decks/{id}
```

#### 获取卡包统计
```
GET /api/v1/decks/{id}/stats
```

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "获取卡包统计成功",
  "data": {
    "total_cards": 5,
    "due_cards": 2,
    "total_tags": 3,
    "today_reviews": 1,
    "week_reviews": 3
  }
}
```

### 标签API

#### 获取卡包下的所有标签
```
GET /api/v1/tags/deck/{deckId}
```

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "获取标签列表成功",
  "data": [
    {
      "id": 1,
      "name": "内存管理",
      "deck_id": 1,
      "created_at": "2023-11-01T10:00:00Z",
      "stats": {
        "total_cards": 2,
        "due_cards": 1
      }
    }
  ]
}
```

#### 创建标签
```
POST /api/v1/tags/deck/{deckId}
```

**请求体**：
```json
{
  "name": "新标签"
}
```

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "标签创建成功",
  "data": {
    "id": 4,
    "name": "新标签",
    "deck_id": 1,
    "created_at": "2023-11-01T10:00:00Z"
  }
}
```

#### 获取单个标签
```
GET /api/v1/tags/{id}
```

#### 更新标签
```
PATCH /api/v1/tags/{id}
```

**请求体**：
```json
{
  "name": "更新的标签名称"
}
```

#### 删除标签
```
DELETE /api/v1/tags/{id}
```

#### 获取标签统计
```
GET /api/v1/tags/{id}/stats
```

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "获取标签统计成功",
  "data": {
    "total_cards": 2,
    "due_cards": 1,
    "today_reviews": 0,
    "week_reviews": 1
  }
}
```

### 卡片API

#### 搜索卡片
```
GET /api/v1/cards?query=关键词&deck_id=1&tag_id=1&page=1&page_size=10
```

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "搜索卡片成功",
  "data": {
    "total": 5,
    "page": 1,
    "page_size": 10,
    "items": [
      {
        "id": 1,
        "question": "Go语言的垃圾回收机制是如何工作的？",
        "answer": "Go语言使用三色标记清除算法进行垃圾回收...",
        "deck_id": 1,
        "tag_id": 1,
        "created_at": "2023-11-01T10:00:00Z",
        "updated_at": "2023-11-01T10:00:00Z"
      }
    ]
  }
}
```

#### 创建卡片
```
POST /api/v1/cards
```

**请求体**：
```json
{
  "deck_id": 1,
  "tag_id": 1,
  "question": "新问题",
  "answer": "新答案"
}
```

#### 获取单个卡片
```
GET /api/v1/cards/{id}
```

#### 更新卡片
```
PATCH /api/v1/cards/{id}
```

**请求体**：
```json
{
  "question": "更新的问题",
  "answer": "更新的答案",
  "tag_id": 2
}
```

#### 删除卡片
```
DELETE /api/v1/cards/{id}
```

#### 获取卡包下的所有卡片
```
GET /api/v1/decks/{deckId}/cards
```

#### 获取标签下的所有卡片
```
GET /api/v1/tags/{tagId}/cards
```

### 导入导出API

#### 导入卡包
```
POST /api/v1/import-export/decks
```

**请求体**：multipart/form-data
- `file`: 要导入的文件（支持 JSON、CSV、TXT 格式）

**响应示例**：
```json
{
  "code": "SUCCESS",
  "message": "导入成功",
  "data": {
    "deck_name": "Go语言基础",
    "total_cards": 5,
    "imported_cards": 5,
    "skipped_cards": 0,
    "tags_created": 3,
    "import_time": "2023-11-01T10:00:00Z"
  }
}
```

#### 导出卡包
```
GET /api/v1/import-export/decks/{deckId}?format=json&group_by_tag=true
```

**参数**：
- `format`: 导出格式（json、csv、txt）
- `group_by_tag`: 是否按标签分组（true/false）

**响应**：文件下载

---

## TXT格式说明

### 基本语法

TXT 格式是一种简单易用的文本格式，用于导入和导出学习卡片。以下是基本语法规则：

1. **标签定义**：以 `#` 开头的行表示标签
   ```
   # 标签名称
   ```

2. **问答对**：使用 `===` 分隔问题和答案
   ```
   这是问题
   ===
   这是答案
   ```

3. **多行文本**：问题和答案都支持多行文本
   ```
   这是一个多行问题
   可以包含多行内容
   ===
   这是一个多行答案
   也可以包含多行内容
   ```

4. **标签继承**：标签会应用到后续的所有卡片，直到遇到新的标签定义
   ```
   # 标签1
   问题1
   ===
   答案1
   
   问题2
   ===
   答案2 
   
   # 标签2
   问题3
   ===
   答案3
   ```
   在上面的例子中，问题1和问题2属于"标签1"，问题3属于"标签2"。

### 标签使用

1. **单个标签**：每个卡片可以属于一个标签
   ```
   # 内存管理
   Go语言的垃圾回收机制是如何工作的？
   ===
   Go语言使用三色标记清除算法进行垃圾回收...
   ```

2. **多标签**：使用逗号分隔多个标签
   ```
   # 内存管理,并发
   Go语言的goroutine和线程有什么区别？
   ===
   1) 创建成本：goroutine创建成本低...
   ```

3. **无标签卡片**：不定义标签的卡片将不归属于任何标签
   ```
   这是一个无标签的问题
   ===
   这是一个无标签的答案
   ```

### 示例文件

以下是一个完整的 TXT 格式示例文件：

```
# Go语言基础

Go语言的垃圾回收机制是如何工作的？
===
Go语言使用三色标记清除算法进行垃圾回收。主要步骤包括：1) 标记阶段：从根对象开始，将可达对象标记为灰色；2) 扫描阶段：将灰色对象引用的对象标记为灰色，并将原灰色对象标记为黑色；3) 清除阶段：回收所有白色（未标记）对象。Go的GC是并发执行的，可以与用户程序同时运行，减少了STW(Stop-The-World)时间。

# 并发

Go语言的goroutine和线程有什么区别？
===
1) 创建成本：goroutine创建成本低，初始栈大小仅2KB，可动态增长；线程创建成本高，通常需要1MB以上栈空间。
2) 调度方式：goroutine由Go运行时调度器在用户态调度，采用M:N模型；线程由操作系统内核调度。
3) 切换成本：goroutine切换成本低，仅需保存少量寄存器；线程切换需要保存完整上下文，成本高。
4) 数量限制：goroutine可轻松创建数十万个；线程数量受系统限制。

Go语言的channel有什么作用？
===
channel是Go语言中用于goroutine之间通信的管道，实现了CSP(Communicating Sequential Processes)并发模型。主要作用：
1) 实现goroutine间的同步和数据传递
2) 提供类型安全的通信机制
3) 支持带缓冲和不带缓冲两种模式
4) 可用于控制并发数量
5) 实现生产者-消费者模式

# 接口

Go语言的接口是如何实现的？
===
Go语言采用隐式接口实现机制，任何类型只要实现了接口中定义的所有方法，就被认为实现了该接口，无需显式声明。接口值由两部分组成：类型和值。空接口interface{}可表示任何类型。

# 基础语法

Go语言的defer语句有什么特点和用途？
===
defer语句用于延迟函数的执行，直到包含它的函数返回时才执行。

特点：
1) 执行顺序：多个defer按LIFO(后进先出)顺序执行
2) 参数求值：defer函数的参数在defer语句执行时求值
3) 可修改命名返回值

主要用途：
1) 资源释放：关闭文件、解锁互斥锁等
2) 异常处理：配合recover捕获panic
3) 代码清理：确保某些操作在函数退出前执行
```

---

## 常见问题解答

### 安装和启动问题

**Q: 启动后端时出现端口占用错误怎么办？**

A: 可以修改 `.env` 文件中的 `PORT` 配置，或者停止占用该端口的进程。

**Q: 前端无法连接到后端API怎么办？**

A: 请检查以下几点：
1. 确保后端服务已启动
2. 检查前端的 `.env` 文件中的 `VITE_API_BASE_URL` 配置是否正确
3. 确保后端和前端使用的端口匹配

**Q: 数据库初始化失败怎么办？**

A: 请检查以下几点：
1. 确保有足够的权限创建和写入数据库文件
2. 检查 `.env` 文件中的 `DB_PATH` 配置是否正确
3. 尝试删除现有的数据库文件，重新启动后端服务

### 导入导出问题

**Q: 导入TXT文件时出现格式错误怎么办？**

A: 请检查以下几点：
1. 确保TXT文件编码为UTF-8
2. 检查问答对是否使用 `===` 正确分隔
3. 确保标签行以 `#` 开头
4. 检查是否有空行或特殊字符导致解析错误

**Q: 导入大文件时超时怎么办？**

A: 可以尝试以下解决方案：
1. 将大文件拆分为多个小文件分别导入
2. 修改后端的超时配置（如果支持）
3. 检查服务器资源是否充足

**Q: 导出的文件无法再次导入怎么办？**

A: 请检查以下几点：
1. 确保导出和导入的格式一致
2. 检查文件是否在导出后被修改
3. 尝试使用其他格式导出和导入

### 学习功能问题

**Q: 为什么有些卡片没有出现在学习队列中？**

A: 可能的原因有：
1. 这些卡片今天不需要复习（根据SM-2算法计算）
2. 这些卡片属于已归档的卡包
3. 这些卡片已被删除

**Q: 如何调整复习间隔？**

A: 复习间隔由SM-2算法自动计算，但可以通过以下方式间接影响：
1. 选择"Again"会缩短复习间隔
2. 选择"Hard"会小幅延长复习间隔
3. 选择"Good"会大幅延长复习间隔

**Q: 学习进度丢失了怎么办？**

A: 请检查以下几点：
1. 确保数据库文件没有损坏
2. 检查是否有多个数据库文件导致数据不一致
3. 尝试从备份恢复数据（如果有）

### 数据管理问题

**Q: 如何备份数据？**

A: 可以通过以下方式备份数据：
1. 使用导出功能将数据导出为JSON、CSV或TXT格式
2. 直接复制数据库文件（flashcard.db）
3. 定期执行完整的数据库备份

**Q: 如何在不同设备间同步数据？**

A: 目前FlashMind主要设计为本地使用，但可以通过以下方式实现数据同步：
1. 使用导出功能导出数据，然后在另一台设备上导入
2. 使用云存储服务同步数据库文件
3. 使用第三方同步工具（如Syncthing）同步数据目录

**Q: 如何删除所有数据重新开始？**

A: 可以通过以下方式重置数据：
1. 删除数据库文件（flashcard.db），然后重新启动后端服务
2. 或者删除所有卡包（注意：此操作不可逆）

---

## 开发指南

### 项目结构

```
FlashMind/
├── backend/                 # 后端代码
│   ├── cmd/
│   │   └── server/
│   │       └── main.go     # 后端入口文件
│   ├── internal/
│   │   ├── config/         # 配置模块
│   │   ├── handlers/       # 请求处理器
│   │   ├── middleware/     # 中间件
│   │   ├── models/         # 数据模型
│   │   └── services/       # 业务逻辑
│   ├── pkg/
│   │   └── database/       # 数据库模块
│   ├── go.mod              # Go模块文件
│   └── .env                # 环境变量配置
├── frontend/               # 前端代码
│   ├── src/
│   │   ├── api/           # API接口
│   │   ├── assets/        # 静态资源
│   │   ├── components/    # Vue组件
│   │   ├── router/        # 路由配置
│   │   ├── services/      # 服务层
│   │   ├── views/         # 页面组件
│   │   └── main.js        # 前端入口文件
│   ├── package.json       # Node.js依赖配置
│   └── vite.config.js     # Vite配置
├── test_data/             # 测试数据
├── docs/                  # 文档
└── README.md              # 项目说明
```

### 运行测试

#### 后端测试

```bash
cd backend
go test -v ./...
```

运行测试并生成覆盖率报告：
```bash
go test -v -cover ./...
```

运行特定测试：
```bash
go test -v ./internal/handlers -run TestImportDeckTXT
```

#### 前端测试

```bash
cd frontend
npm test
```

运行测试并生成覆盖率报告：
```bash
npm run test:coverage
```

运行测试UI界面：
```bash
npm run test:ui
```

#### 运行所有测试

使用项目提供的脚本：
```bash
./run_tests.sh
```

### 贡献指南

1. **Fork 项目**
   - 在GitHub上Fork FlashMind项目

2. **创建功能分支**
   ```bash
   git checkout -b feature/your-feature-name
   ```

3. **提交更改**
   ```bash
   git commit -am "Add your feature"
   ```

4. **推送分支**
   ```bash
   git push origin feature/your-feature-name
   ```

5. **创建Pull Request**
   - 在GitHub上创建Pull Request，描述您的更改

#### 代码风格

- **Go代码**：遵循Go官方代码风格，使用 `gofmt` 格式化代码
- **Vue代码**：使用ESLint和Prettier保持代码风格一致
- **提交信息**：使用清晰的提交信息，格式为 `类型: 描述`

#### 测试要求

- 所有新功能必须包含相应的测试
- 确保所有测试通过后再提交Pull Request
- 保持测试覆盖率不低于当前水平

### 一键脚本详细说明

项目提供了三个主要的管理脚本，简化开发和部署过程：

#### start.sh - 启动脚本

**功能特性**：
- 自动检测并停止现有服务（重启功能）
- 自动安装所有依赖（Go mod download, npm install）
- 编译Go后端服务
- 启动前后端服务
- 服务健康检查
- 详细的状态输出和错误处理

**使用方法**：
```bash
./start.sh
```

**输出信息**：
- 服务启动状态
- PID信息
- 访问地址
- 日志文件位置

#### stop.sh - 停止脚本

**功能特性**：
- 优雅停止所有服务
- 强制终止无响应进程
- 清理PID文件
- 可选的日志文件清理

**使用方法**：
```bash
# 停止所有服务
./stop.sh

# 停止服务并清理日志
./stop.sh --clean-logs

# 查看帮助信息
./stop.sh --help
```

#### status.sh - 状态检查脚本

**功能特性**：
- 详细的服务运行状态
- 进程信息和资源使用情况
- 端口占用检查
- HTTP服务健康检查
- 系统信息和网络状态
- 日志文件摘要

**使用方法**：
```bash
./status.sh
```

**输出信息**：
- 服务运行状态
- 进程详情（PID、CPU、内存使用）
- 端口占用情况
- HTTP响应状态
- 系统资源使用情况
- 最近日志摘要

#### 日志管理

所有脚本都会生成日志文件：
- `backend.log` - 后端服务日志
- `frontend.log` - 前端服务日志

实时查看日志：
```bash
# 查看后端日志
tail -f backend.log

# 查看前端日志
tail -f frontend.log

# 同时查看两个日志
tail -f backend.log frontend.log
```

#### 故障排除

常见问题和解决方案：

**端口被占用**：
```bash
# 检查端口占用
lsof -i :8080
lsof -i :5173

# 使用脚本停止
./stop.sh
```

**服务启动失败**：
```bash
# 检查详细状态
./status.sh

# 查看错误日志
cat backend.log
cat frontend.log
```

**依赖问题**：
```bash
# 清理并重新安装
rm -rf frontend/node_modules
rm -f frontend/package-lock.json
cd frontend && npm install

cd ../backend
go clean -modcache
go mod download
```

**完全重置**：
```bash
./stop.sh --clean-logs
rm -f .backend.pid .frontend.pid
rm -f backend/flashcard.db
./start.sh
```

---

## 附录

### 快捷键参考

| 功能 | 快捷键 |
|------|--------|
| 显示答案 | 空格键 |
| 选择Again | 1键 |
| 选择Hard | 2键 |
| 选择Good | 3键 |
| 下一张卡片 | Enter键 |
| 上一张卡片 | 左箭头键 |
| 翻转卡片 | F键 |

### SM-2算法参数说明

FlashMind使用SM-2算法计算复习间隔，主要参数包括：

- **efactor**：难度因子，初始值为2.5
- **interval**：复习间隔（天），初始值为0
- **repetitions**：连续正确复习次数，初始值为0
- **next_review**：下次复习时间

反馈规则：
- **Again**：重置 `repetitions`，`interval` 设为1，`efactor` 下调
- **Hard**：小幅上调 `interval`，`efactor` 微调
- **Good**：正常递增 `interval`，`efactor` 小幅提升/保持

### 数据库表结构

#### decks表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | INTEGER | 主键 |
| name | TEXT | 卡包名称 |
| archived | BOOLEAN | 是否归档 |
| created_at | DATETIME | 创建时间 |

#### tags表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | INTEGER | 主键 |
| deck_id | INTEGER | 卡包ID（外键） |
| name | TEXT | 标签名称 |
| created_at | DATETIME | 创建时间 |

#### cards表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | INTEGER | 主键 |
| deck_id | INTEGER | 卡包ID（外键） |
| tag_id | INTEGER | 标签ID（外键，可空） |
| question | TEXT | 问题 |
| answer | TEXT | 答案 |
| created_at | DATETIME | 创建时间 |
| updated_at | DATETIME | 更新时间 |

#### reviews表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | INTEGER | 主键 |
| card_id | INTEGER | 卡片ID（外键） |
| efactor | FLOAT | 难度因子 |
| interval | INTEGER | 复习间隔（天） |
| repetitions | INTEGER | 连续正确复习次数 |
| next_review | DATETIME | 下次复习时间 |

---

## 许可证

FlashMind 采用 MIT 许可证。详情请参阅 [LICENSE](LICENSE) 文件。

## 联系方式

如有问题或建议，请通过以下方式联系：

- 提交 Issue：[GitHub Issues](https://github.com/yourusername/FlashMind/issues)
- 邮箱：your.email@example.com

## 更新日志

### v1.0.0 (2023-11-01)

- 初始版本发布
- 支持卡包、标签、卡片的基本管理
- 实现基于SM-2算法的学习功能
- 支持JSON、CSV、TXT格式的导入导出
- 提供完整的Web界面